{% extends "base.html.twig" %}

{% block title %}Reports{% endblock %}

{% block body %}
    <article class="art-row">
        <div class="div-col-1">
            <h2>Reports</h2>
            <ul class="about-links">
                <li><a href="#kmom01">Kmom 01</a></li>
                <li><a href="#kmom02">Kmom 02</a></li>
                <li><a href="#kmom03">Kmom 03</a></li>
                <li><a href="#kmom04">Kmom 04</a></li>
                <li><a href="#kmom05">Kmom 05</a></li>
                <li><a href="#kmom06">Kmom 06</a></li>
                <li><a href="#kmom10">Kmom 10</a></li>
            </ul>
        </div>

        <div class="div-col-2">
            <h2 id="kmom01">Kmom 01</h2>
            <p><b>Berätta kort om dina förkunskaper och tidigare erfarenheter kring objektorientering.</b></p>
            <p>Jag har ju gått några tidigare kurser som behandlat objektorientering, den som jag spontant tänker på är oopython-kursen och även om det var ett tag 
            sedan så minns jag ändå grunderna kring ett objektorienterat förhållningssätt till kod.</p>
            <p><b>Berätta kort om PHPs modell för klasser och objekt. Vilka är de grunder man behöver veta/förstå för att kunna komma igång och skapa sina första klasser?</b></p>
            <p>Klasser och objekt i php fungerar lite som inkapslade segment utav kod som är knutna till klassen eller objektet dessa kan vi sedan välja själva hur vi manipulerar dem 
            eller vilken åtkomst som skall ges till de specifika delarna för en användare eller för all del en kollega. De grunder jag tänker är viktiga att förstå för att komma igång 
            med klasser och object är kanske framför allt just att förstå att attribut och metoder är kopplade till klassen/objektet och att vi beroende på hur vi skriver klassen också 
            kan bestämma hur dessa ska vara möjliga att komma åt eller ändra. En annan viktig, användbar och intressant aspekt av det hela är arv, det går nämligen att ärva attribut och 
            metoder från en klass. Det är något som kan vara mycket användbart om än lite svårare att få en övergriplig koll på.</p>
            <p><b>Reflektera kort över den kodbas, koden, strukturen som användes till uppgiften me/report, hur uppfattar du den?</b></p>
            <p>Jag tror jag känner samma saker nu som när jag arbetade med en tidigare version av kursen som då hette oophp. Det är väldigt trevligt att använda en struktur som denna 
            i skapandet av en me-page då det här mer modullära förhållningssättet gör det enklare att dela upp och hålla koll på vad respektive modul eller del gör och ska göra. 
            Det som komplicerar det blir då snarare själva pusslandet med modulerna och att skapa sig en översikt kring vart saker skall vara och vart de passar in och hur själva kopplingarna 
            görs.</p>
            <p><b>PHP The Right Way, vilka delar in den finner du extra intressanta och värdefulla?</b></p>
            <p>Jag fastnade framför allt för kapitel 7 och mer specifikt delen kring S.O.L.I.D. det känns som ett bra tänk att ha för att kunna återanvända kod på ett bra och 
            smidigt sätt. Framför allt fastnade jag på O'et som står för Open/Closed Principle, alltså att klasser med mera skall vara designade på ett sådant sätt att de kan byggas på 
            men att det som redan är en del av dem inte ska modifieras. Jag tänker instinktivt att det kan bespara en mycket huvudbry om man kan hålla sig till den principen, framför allt 
            när kodbasen växer i storlek. Jag kan tänka mig ett scenario där mycket kod förlitar sig på en klassmetod eller liknande och den ändras (vilket vore emot principen) vilket leder 
            till att massa andra delar utav koden slutar fungera. Det scenariot låter som en källa till mycket, mycket arbete. Sen gäller det att lyckas hålla sig till dessa principer också 
            men det tänker jag kommer genom övning, arbete och att man gör sådana kostsamma misstag.</p>
            <p><b>TIL för detta kmom?</b></p>
            <p>Att det ibland är allt strul som man lär sig mest av. Jag hade mycket strul med php-versioner, npm-versioner, nodeJS-versioner etc i ubuntu men jag lärde mig genom det också 
            att man kan ha flera versioner av dessa saker samtidigt, hur man införskaffar dem samt hur man växlar mellan dom.</p>

            <h2 id="kmom02">Kmom 02</h2>
            <p><b>Förklara kort de objektorienterade konstruktionerna arv, komposition, interface och trait och hur de används i PHP.</b></p>
            <p>Arv handlar om att klasser kan ärva funktionalitet utav varandra, just specifick i PHP från en förälder till ett barn och det går inte med multipelt arv. Ett exempel 
            skulle kunna vara en klass som representerar en bil, en bil har en ratt. Både en volvo och en batmobile är bilar så de kan ärva viss basfunktionalitet från bil-klassen för att 
            sedan utöka eller modifiera den.</p>
            <p>Komposition handlar om relationen mellan klasser. En relation där en klass inte kan existera utan en annan är en så kallad komposition</p>
            <p>Ett interface är som ett kontrakt som en klass kan lova att uppfylla genom att implementera det, all objekt som implementerar samma interface lovar alltså att 
            tillhandahålla de metoder som interfacet kräver.</p>
            <p>Trait skulle man kunna säga är som en klass som innehåller funktionalitet som flera andra klasser kan använda sig utav utan att behöva ärva</p>
            <p><b>Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden och dina klasser?</b></p>
            <p>Uppgiften var rolig, känner mig fortfarande ringrostig sedan oophp men det är klart att gammal erfarenhet hjälper. Jag tycker dock att uppgiften var mer komplex än vad den var 
            i oophp och det tog mig därför en hel del tid, mycket lärorik tid. Jag är mestadels nöjd och tycker jag klarat uppgiften adekvat, jag stod tidigt vid ett vägskäl kring hur 
            jag ville representera mina kort och hur de utifrån detta även kan sorteras. Jag valde inte att ge varje kortobjekt någon id-variabel eller liknande för att underlätta sortering 
            utan det blev en mer tidskrävande lösning som jag ändå känner mig rätt nöjd med även om den säkert kan skrivas snyggare. Det finns garanterat förbättringar att göra, kanske bryta ut 
            funktionalitet i traits? Sen fick momentet mig att reflektera mycket kring vad som faktiskt är bra kod, hur "verbose" skall man vara när man skriver sin kod? Vart går gränsen där 
            koncis och effektiv kod blir svårläslig och inte längre är "snygg"?</p>
            <p><b>Vilka är dina reflektioner så här långt med att jobb i Symfony med applikationskod enligt MVC?</b></p>
            <p>Det känns rätt trevligt faktiskt, tycker det här momentet verkligen gav en övning att hitta mellan routes, hantera formulär och följa flödet i sin kod och mellan filerna. Däremot 
            kan det upplevas lite svårt att felsöka ibland när det blir lite diffust vad det är symfony klagar på och man får ta till lite fulingar med echo och print_r.</p>
            <p><b>Vilken är din TIL för detta kmom?</b></p>
            <p>Att det kan vara bökigt att sortera objekt när man väljer att sortera dom efter deras properties. Men det som kräver mycket möda känns så mycket bättre när man väl löser det.</p>

            <h2 id="kmom03">Kmom 03</h2>
            <p><b>Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod. Var det något som du tror stödjer dig i din problemlösning och tankearbete för att strukturera koden kring en applikation?</b></p>
            <p>Det var både mycket givande och lite utmanande. Framför allt så hjälper det en att organisera tankarna och att spåna fram en mer övergriplig och generell lösning som man sedan 
            kan ha som utgångspunkt och vägledning under kodandet. Utmaningen för mig var nog snarare skrivandet av själva pseudokoden, det blir lite lustigt när det inte finns en 
            standard för hur det ska skrivas. Den guide som fanns var givande men också något svårläst och dessutom blir det lite halvkonstigt att skriva pseudokod i början av ett arbete som 
            inte nödvändigtvis representerar utseendet på den slutgiltiga "riktiga" koden. Men likt flödesschemat så är det ett användbart sätt att komma till start genom och ett bra sätt att börja 
            bygga en mental skiss över hur uppgiften skall lösas.</p>
            <p><b>Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden, dina klasser och applikationen som helhet?</b></p>
            <p>Det finns givetvis alltid förbättringspotential, just med min lösning skulle jag säga att traits fortfarande är någonting jag kan tänka mig vara användbart. Huruvida de gör koden snyggare 
            eller inte är kanske debatterbart men det finns nog definitivt kod i mina klasser som skulle kunna implementeras via traits. Annars känner jag mig rätt så nöjd över hur jag löste 
            uppgiften, om än den mest basala versionen av den. Jag hade som intention att fokusera på dependency injection och det tycker jag att jag lyckades rätt så bra med, fast det kan initialt 
            kännas som att det blir onödigt mycket kod som repeteras eller används men i längden gör det kodbasen mer flexibel att arbeta med vilket är trevligt. Det lärde ju denna uppgiften oss redan 
            i form utav återanvändandet av kortleken och korten. Däremot lät jag spelet istället för klassen som representerade motståndaren att sköta motståndarens "logik". Det kunde flyttats till 
            motspelarklassen i enlighet med min ursprungliga plan och är kanske en bättre lösning främst när logiken blir mer komplex eller i form utav dependency injection där beroende på vilken 
            mostståndare vi har så är det själva motståndaren som sköter sin logik snarare än spelet och spelet kan då anropa motståndarobjektet och få ett svarsbeslut istället för att spelet självt 
            bestämmer motståndarens logik. Men det kändes enklare för nu att låta spelet sköta logiken, definitivt förbättringspotential där dock.</p>
            <p><b>Vilken är din känsla för att koda i ett ramverk som Symfony, så här långt in i kursen?</b></p>
            <p>Det känns trevligt, blir mer och mer varm i kläderna när det kommer till att lägga/hitta saker på rätt plats i strukturen. Sen finns det fortfarande massor med detaljer kvar att lära 
            kring just symfony.</p>
            <p><b>Vilken är din TIL för detta kmom?</b></p>
            <p>Att det verkligen kan hjälpa felsökningen att berätta för sig själv om flödet i koden och vad som bör hända samtidigt som man följer efter i koden som skrivits. Lite som 
            rubber duck debugging.</p>

            <h2 id="kmom04">Kmom 04</h2>
            <p><b>Berätta hur du upplevde att skriva kod som testar annan kod med PHPUnit och hur du upplever phpunit rent allmänt.</b></p>
            <p>Jag tycker det är rätt trevligt, framför allt är det ett väldigt bra sätt att just testa sin kod på ett mer strukturerat sätt. Innan användingen av phpunit så 
            blev det ju snarare så att testningen av koden skedde "live" genom att spela igenom spelet, trycka runt på me-sidan och sen försöka förstå varför saker gick sönder när 
            dom gick sönder. Phpunit är ju väldigt trevligt just på det sättet att det låter oss testa varje individuell funktion eller metod i förväg och på så sätt något så när 
            försäkra oss om att de agerar som förväntat. Det beror givetvis på hur välskrivna testen är.</p>
            <p><b>Hur väl lyckades du med kodtäckningen av din kod, lyckades du nå mer än 90% kodtäckning?</b></p>
            <p>Jag lyckades nå 100% på alla klasser som är involverade i mitt kortspel, det är ju väldigt svårt att nöja sig när man träffat 90% redan. Sen är kanske inte 100% 
            målet i sig, och definitivt ingen garanti på att koden är bra eller bra testad men det är såklart kul att se att allt är grönt. Sen hade jag kanske inte siktat på 100% om 
            det hade tagit extremt mycket tid, vilket i och för sig hade varit en indikation på större problem.</p>
            <p><b>Upplever du din egen kod som “testbar kod” eller finns det delar i koden som är mer eller mindre testbar och finns det saker som kan göras för att förbättra kodens testbarhet?</b></p>
            <p>Jag tycker att den kändes förvånandsvärt testbar och jag fick en kännsla av att det är på grund utav att jag valde tidigt att fokusera på dependency injection. Det i kombination 
            med hur jag hade byggt upp respektive klasser gav en kod som var väldigt flexibel när den skulle testas och innebar till min förvåning att jag inte behövde mocka något även om jag hade 
            gjort den övningen. Det fanns givetvis detaljer som inte var helt testbara så jag modifierade min kod lite för att göra dem nåbara men på det stora hela kändes det testbart. Något jag tar med 
            mig är definitivt att mindre metoder och funktioner känns mycket lättare att testa, och att testa adekvat.</p>
            <p><b>Valde du att skriva om delar av din kod för att förbättra den eller göra den mer testbar, om så berätta lite hur du tänkte.</b></p>
            <p>Jag skrev om mindre delar som gjorde det möjligt att komma åt vissa medlemsvariabler. Jag tänkte att det var ett okej sätt att lösa testbarheten då alternativet hade varit att skriva 
            om mycket funktionalitet. Jag tyckte ändå min kod var rätt testbar (kan vara min egen naivitet) så det kändes som rätt vägval. Eftersom jag har en del metoder som inte enbart returnerar 
            något utan de muterar även vissa medlemsvariabler så behövs vissa metoder som returnerar dessa medlemsvariabler för att kontrollera att de muterats på rätt sätt.</p>
            <p><b>Fundera över om du anser att testbar kod är något som kan identifiera “snygg och ren kod”.</b></p>
            <p>Jo men delvis tycker jag nog att det i alla fall är en indikator på snygg kod, nu är det ju delvis ett subjektivt mått så det är svårt att säga bestämt. Om saker som dependency injection 
            och mindre funktioner/metoder och återanvändbar kod (och därmed flexibel) är att klassa som snygg kod och dessa dessutom underlättare testning så tycker jag väl att man kan säga att där finns 
            en indikator på snygg kod.</p>
            <p><b>Vilken är din TIL för detta kmom?</b></p>
            <p>Att flexibla klasser och dependency injection verkligen kan underlätta testning och att 100% kodtäckning inte är en garant för välskriven och felfri kod.</p>

            <h2 id="kmom05">Kmom 05</h2>
            <p><b>Gick det bra att jobba igenom övningen med Symfony och Doctrine. Något särskilt du tänkte/reagerade på under övningen?</b></p>
            <p>Både ja och nej skulle jag vilja påstå. Allt som hade med doctrine i sig gick förhållandevis bra och jag tycker guiden var bra samt deras egen dokumentation 
            däremot så hade jag ett otroligt strul vad gäller själva databaserna. Dels är det massa strul bara att få MySql Workbench att fungera med en databas på WSL Ubuntu då databasen ligger 
            på WSL medan workbench ligger på windows. Går att skaffa workbench till WSL Ubuntu med men den är inte tänkt att köras genom wsl utan snarare med linux som huvud-os. Efter det så bråkar 
            samtliga verktyg om samma portar, dvs xampp, mariadb på wsl ubuntu och MySql från workbench så där gäller det att ha koll på vad som är igång eller inte samt vilka portar de körs på. 
            Detta var samantaget ändå ett lite strul till skillnad från mina försök att köra biblioteksdatabasen på mariadb i mitt WSL Ubuntu och på mariadb på studentservern. Jag fick det för det 
            mesta att fungera, även om det tog tid, och jag kunde både nå min lokala mariadb samt studentserverns mariadb via workbench och terminalen men av någon anledning så släppte inte min 
            me-page kopplingen till den tidigare sqlite-databasen utan symfonysidan i sig tycktes fortfarande använda sig utav den datasbasfilen. Jag läste på i timmar och testade olika saker men 
            jag fick det inte att fungera och var till slut tvungen att fatta beslutet att det är tid som spenderas på fel plats och rätt väg frammåt är att fortsätta med sqlite och kommentera ut 
            variablerna i .env.local och .env.student.local</p>
            <p><b>Berätta om din applikation och hur du tänkte när du byggde upp den. Tänkte du något speciellt på användargränssnittet?</b></p>
            <p>Jag tänkte att jag ville uppnå någon slags blanding mellan hur jag visat upp kortspelen tidigare och hur böcker visas upp på en bokhandel online så det blev lite 
            "card-inspirerat" på mer än ett sätt. Och jag tycker jag lyckades rätt så skapligt och producerade en ganska trevlig användarupplevelse. Framför allt ville jag att det skulle flyta 
            på bra och att det skulle finnas skillnader (även små) mellan de olika vyerna så att det var tydligt vad som försiggick. Från en trevlig landningssida som visar upp en liten del av 
            böckerna till att böckerna endast kan raderas via vyn för det ändamålet. Däremot finns det givetvis brister som skulle bli uppenbara om biblioteket växte i storlek, då kan man t.ex. inte 
            sitta och enbart scrolla genom böckerna utan även en slags sökfunktion hade varit användbar.</p>
            <p><b>Gick det bra att jobba med ORM i CRUD eller vad anser du om det, jämför gärna med andra sätt att jobba med databaser?</b></p>
            <p>Jag tycker det gick bra mestadels, tyckte dock det var lite struligt att få saker att fungera likandant på studentservern som i min lokala miljö men det gick att lösa ganska smärtfritt. 
            Just när det kommer till själva ORM och CRUD så kändes det bra men det är ju helt klart en hel del magi och även om det känns mycket mer objektorienterat så är det en del nytt att lära 
            när man inte vet alla smarta funktioner som finns i doctrine. Så stundtals kändes det kanske väl magiskt men å andra sidan behövde jag inte skriva massa råa sql-satser.</p>
            <p><b>Vad är din uppfattning om ORM så här långt och relatera gärna till andra sätt att jobba med applikationskod mot databaser?</b></p>
            <p>Tycker som sagt att det är trevligt, och spar en hel del skrivande. Däremot kräver det ju att man är något insatt i själva magin. Man måste givetvis inte vara det och det är väl på ett 
            sätt också det som är en av fördelarna med det men om och när någonting går fel så kan det vara trevligt att ha någon uppfattning om vad det är som sker. Nu var det ett tag sedan jag satt 
            med just databaskursen då detta är en kurs jag är omregistrerad på men detta ger mig definitvt lite av kännslan jag fick när vi arbetade med hemsidor i vanilla javascript och sedan med 
            t.ex. react. Mer magi och mindre verbosity, och fördelarna är att det går snabbare, använder färre rader och man behöver inte riktigt veta och kunna detaljerna som sker i bakgrunden. 
            Det blev lite lätt konfunderande ibland dock, jag försökte likt tidigare kursmoment hålla min controller smal och mina klasser feta så jag försökte hantera det mesta som skedde gentemot 
            databasen i repositoryklassen men det var inte alltid helt enkelt att se vad som vär rätt eller bästa sättet att lösa det hela på.</p>
            <p><b>Vilken är din TIL för detta kmom?</b></p>
            <p>Att precis som att små commits är användbara så kan det vara fördelaktigt att testa att sakerna fungerar på studentservern lite mer frekvent än att göra det i slutet av ett kursmoment, 
            i det här fallet besparade det mig mycket huvudbry.</p>
            <h2 id="kmom06">Kmom 06</h2>
            <p><b>Hur uppfattade du verktyget phpmetrics och fann du några särskilda bitar mer värdefulla än andra? Var det några särskilda metrics eller bilder du uppskattade?</b></p>
            <p>Framför allt uppfattade jag phpmetrics som lite mer komplicerat och svårare att ta till sig än andra verktyg vid arbetade med och har arbetat med. Samtidigt så gav det en väldigt 
            detaljerad bild av min kodbas. Så jag uppskattar verkligen detaljerna med verktyget men det gäller att sätta sig in i vad de pekar ut och hur man skall lösa det. Jag uppskattade nog cirklarna 
            mest faktiskt, de som visas på "startsidan" som ger en snabb överblick kring hur komplex och stor klassen är, även om det i mitt fall innebar en grafisk representation av ordet förbättringspotential. 
            Sen vill jag också nämna att jag uppskattade de objektorienterade vyerna som på ett tydligt sätt listade cohesion, coupling samt komplexitet och antal tester som kördes mot respektive klass. 
            Den vyn gjorde det mycket enklare att snabbt få en överblick kring vilka klasser som kanske behövde poleras som mest.</p>
            <p><b>Berätta hur det gick att integrera med Scrutinizer och vilken är din första känsla av verktyget och dess badges? Vilken kodtäckning och kodkvalitet fick du efter första bygget?</b></p>
            <p>Scrutinizer var väldigt trevligt att arbeta med och det var enkelt att integrera. Den stora nackdelen med scrutinizer är nog framför allt den tid det tar att få ett resultat varje gång 
            vi pushar något till github. Främst blir det irriterande när man inte riktigt vet om man löst ett issue på adekvat sätt enligt scrutinizer och då får man vänta mellan 3-30min varje gång man testar. 
            Däremot är det ett väldigt intuitivt verktyg för att förstå sin kod genom, och det målar verkligen upp en tydlig bild av vart det enligt verktyget finns saker att förbättra. Min favoritdel av 
            scrutinizer måste nog vara vyn för "hot spots" som inte bara ger dig en snabb överblick kring vilka klasser som den anser kan förbättras som mest utav även på metod eller funktionsnivå. Det guidade 
            mig verkligen till vad jag skulle fokusera på när jag satsade på att minska komplexiteten i min kod och ledde dessutom till förbättringar. Däremot vet jag inte riktigt om jag är helt såld på just 
            badges, visst de ger en extremt snabb överblick av ett projekt men likt det Mikael lyfte på en av föreläsningarna så är inte dessa badges allt som räknas, det finns projekt med mindre bra badges som ändå 
            är välanvända och som gör det dom ska. Så badges är inte allt, sen är det precis som med kodtäckningen i tidigare moment lätt att vilja ha allt så grönt som möjligt och nå 10.0 och 100% passing men 
            det är snarare något att sikta mot än ett ändamål i sig. Jag fick 9.79, 29% coverage, passing efter mitt första bygge vilket jag känner mig nöjd med, men det var svårt att höja då de största förbättringarna 
            troligtvis låg i mina controllers men dom har jag inte lärt mig testa ännu. Däremot lyckades jag ändå öka mina tester, och testa redan täckt kod mer utförligt samt att göra vissa medtoder mindre 
            komplexa vilket ändå gav resultat.</p>
            <p><b>Hur är din egen syn på kodkvalitet, berätta lite om den? Tror du man kan man påvisa kodkvalitet i någon viss mån med badges eller vad tror du?</b></p>
            <p>Min egen syn på kodkvalitet skiftar nog lite men framför allt har momenten fram till och inklusive detta fått mig att uppskatta verktyg till den grad att de är goda källor till tips och analys. 
            Men viktigast av allt anser jag fortfarande är att koden fungerar och gör det den ska. Dessutom är god kodkvalitet mer än att bara använda sig utav verktygen, det är nog så viktigt att 
            faktiskt ta in det dom säger till dig och det tar tid och övning bara det. God kodkvalitet är något jag känner kommer med tid, arbete och misstag. Ingenting har varit så lärorikt hittills som när jag 
            gjort saker på ett sätt som sedan kommit att kosta mig i ett senare skede och då tänker jag mycket på sådana till synes enkla saker som att skriva lätttestad kod eller att ha små metoder/funktioner som gör 
            en sak, eller att ha klasser som enbart sysslar med sina saker och det som hör till dom så får andra saker skötas av en annan klass eller lösas på annat sätt. Det blev väldigt uppenbart för mig när 
            vi började testa vår kod, att oj den här metoden som gör väldigt mycket blev väldigt svår att testa. Eller en klass som är uppbyggd på ett visst sätt blev också svår att testa medan en annan klass som 
            var uppbyggd på ett mer tillmötesgående sätt var lättare att testa och behövde inte ens mockas. Jag tror likt alla dessa verktyg, likt principer från "php the right way" och linters med mera alla har 
            en sak gemensamt, de är fingervisningar mot mer kvalitativ kod snarare än garanter för det. Visst, är det grönt överallt och inget verktyg hittar några problem så finns där troligtvis ett visst mått av 
            kvalitet att finna men det är långt ifrån en säkerhet. Likt att en vältäckt kod inte automatiskt betyder en vältestad kod. Dessutom är kodkvalitet till viss mån också subjektivt och det är säkerligen 
            inte alla som håller med om alla principer eller som tycker att alla verktyg är fruktbara utan det varierar troligtvis från person till person, arbetsplats till arbetsplats och projekt till projekt.</p>
            <p><b>Vilken är din TIL för detta kmom?</b></p>
            <p>Att det kan vara lika eller mer viktigt att förstå vad verktygen säger dig än att dess värden är så bra som möjliga.</p>
            <h2 id="kmom10">Kmom 10 / Projekt</h2>
            <p><b>Krav 1,2,3 baskrav</b></p>
            <p>Först och främst valde jag att skapa ett retro-esque äventyrsspel. Det kändes som en kul utmaning som var något nytt men det tog mycket tid. Dels för att det inte fanns 
            lika mycket att bygga vidare på jämfört med exempelvis blackjackuppgiften. Dessutom krävdes det en avsevärd ansträngning för att försöka hålla storleken rimlig, det är 
            otroligt lätt att flyga iväg med tusen idéer om vad som borde vara möjligt eller hur någonting skulle kunna tänkas fungera.</p>
            <p>För att få projektet att upplevas som en ny webbplats så valde jag att implementera en ny "bas-template" som alltså var frikopplad från min vanliga template till min 
            me-sida. Det är möjligt att ta sig till mitt projekt från me-sidan men när man väl är på projektets sida så finns det inga vägar tillbaka utan projektsidan är sin egen 
            entitet. Utöver det så valde jag att behålla samma css-fil som jag tidigare använt för style och jag valde att istället för att skapa ett nytt style sheet så arbetade jag 
            med klasser på mina html-element som jag sedan kunde styla från samma style sheet. Jag tyckte delvis att det kändes lättare så och då kunde jag dessutom återanvända mig utav 
            styling sedan tidigare som var användbar och genom att lägga till ytterligare klasser så kunde de användas utan att projektets sida kändes liknande me-sidan. Jag valde också att 
            arbeta med andra färger och ett annat typsnitt för att skapa en mer retro känsla.</p>
            <p>Jag updaterade min readme för mitt repo så det breskrev hur man klonade det samt installerade dependencies samt startar upp en local server för att köra webbplatsen på. Vissa delar 
            är kvar sedan tidigare men har dubbelkollats, t.ex. så uppdateras mina scrutinizer badges automatiskt men de har testats för att se att de fortfarande leder rätt.</p>
            <p><b>Allmänt</b></p>
            <p>Det var en intressant och utmanande uppgift att försöka göra ett äventyrsspel från basen och försöka implementera delar av det vi lärt oss under kursen, jag hade gärna arbetat vidare 
            med JSON API och ORM som jag hade tankar kring hur jag skulle använda men i mån av tid valde jag att inte göra dessa krav då jag inte vill att de skulle ske på bekostnad av kommande kurser. Det var 
            i vilket fall en väldigt rolig uppgift att just bygga upp och skapa spelet på ett sådant sätt det var möjligt att lägga till rum och prylar på ett dynamiskt sätt snarare än att hårdkoda det. 
            Nu blir ju alltid saker i viss mån hårdkodade då jag i min controller bestämmer vilka rum och saker som skall existera men jag antog utmaningen i att programmera spelets klasser på 
            ett vis som låter mig skapa om spelet på vilket sätt jag vill. Det var mycket givande att sitta och klura på den delen.</p>
            <p>På det stora hela tycker jag projektet gick bra att genomföra men det var svårt till en början när jag till skillnad från om jag valt blackjack inte hade något att utgå ifrån 
            så det blev mycket klurande i början kring hur jag ville bygga upp spelet och hur jag skulle lösa det på bästa sätt så det gick ju en hel del tid bara till att konceptualisera. 
            På det stora hela tycker jag inte projektet var så svårt, det hade inte heller varit svårt att implementera ett ORM eller leverera JSON men det tog mycket tid, beroende på hur stort man 
            tänker givetvis. Svårast var nog att fundera ut hur jag skulle lösa kopplingarna mellan rummen på bästa sätt, och delvis hanteringen av möjligheten att låsa möjligheten att gå frammåt 
            i vissa rum beroende på om rätt föremål har lämnats in eller ej. Jag känner mig nog mest nöjd med hur jag löste kopplingarna mellan rummen samt hur rum skapas. Jag valde att göra en basklass 
            för ett rum som i sitt skapande tar emot vissa parametrar och sedan använde jag mig av arv från den basklassen när jag ville skapa mer specialiserade rum. Nu blev de specialiserade 
            rummen inte jättekomplexa men på det viset kunde jag skapa rum med namn, beskrivning och bild direkt i controllern om jag ville eller skapa ett specialiserat rum som är sin egen klass som ärver 
            från basklassen där jag kan ändra på viss funktionalitet eller hårdkoda beskrivning, namn, bild etc. Jag valde att göra så för att inte behöva skapa långa beskrivningar av respektive rum 
            i min controller utan på det här viset kunde jag fylla på sådant i respektive klass, men möjligheten fanns där om man ville.</p>
            <p>Jag löste kopplingarna mellan rummen på det sättet att varje rum hade en key-value array som representerade de väderstreck som kan utgå från ett rum, sedan har varje rum en metod där ett rum då kan läggas till som value till en sådan key. Så jag kunde 
            själv bestämma att från rum nummer tre så finns rum fyra till norr, rum ett till söder etc. Det fungerade bra och kändes som ett dynamiskt sätt att bygga upp kopplingarna mellan rummen, och när spelet bytte 
            aktivt rum så länkades det rum man kom ifrån till motsatt riktning i det nya rummets kopplingar. Det kändes som en smart lösning men jag märkte att ju fler rum jag skapade desto svårare 
            var det att hålla koll på vilken av vädersträcken som ledde tillbaka till föregående rum så jag valde att skapa en till riktning som var "Gå tillbaka", på så vis blir det mycket lättare 
            för spelare att navigera till föregående rum. Sedan valde jag för att det var kul att även vid spelets uppstart att randomisera alla kopplingar mellan rummen, det är fult på ett sätt 
            då de hårtkodar spelet även om jag byggt spelet så att en dynamisk möjlighet fortfarande finns där men samtidigt var den en kul utmaning och gör det enkelt att skapa spelet i kontrollern. 
            Jag skickar helt enekelt in en array med rumsobjekt till min överordnade spelklass som sedan randomiserar kopplingarna mellan dessa rum och sedan startar spelet.</p>
            <p>Svårt? Ganska. Onödigt? Kanske. Roligt? Definitivt. Lärorikt? Absolut.</p>
            <p>Sedan finns det som alltid massor av utvecklingspotential. Jag lärde mig verkligen värdet av att skapa en plan eller en skiss över hur jag tänkte projektet skulle se ut innan jag 
            påbörjade själva programmeringen. Sen är jag definitivt inte nöjd med hur komplexa vissa metoder blev eller hur stora mina klasser blev och det är något jag tar med mig. Jag blev 
            dock nöjd över att jag lyckades hålla mina metoder feta och min controller smal. Och det var lite roligt att gräva sig ned lite mer i vad man kan göra i twig, något som jag använde mig lite av 
            för att dynamiskt visa vissa saker på spelplanet beroende på hur AdventureGame-objektet såg ut.</p>
            <p><b>Tankar kring kursen</b></p>
            <p>Jag skulle vilja nämna att jag har haft förmånen att gå en tidigare version av denna kurs, dock utan att genomföra kmom06 och 10. Jag valde av olika skäl att göra om hela denna 
            kurs och jag tycker den utvecklats något otroligt. Så stor eloge till Mikael och alla som arbetar med att uppdatera kursen. Den hade ett ännu bättre upplägg, en tydligare röd tråd där 
            kursmomenten verkligen kompletterade varandra och det var väldigt roligt att testa på ett ramverk i php. Jag är mycket nöjd med kursen och kommer rekommendera den varmt till vänner som 
            funderar på att testa programmering. Det enda förbättringsförslag jag kan komma på är att det blev lite konstigt under ORM-delen av kursen där jag gärna hade fått mariadb att fungera men det 
            kändes inte riktigt som att det fanns tid att få det att fungera tillsammans med studentservern. Jag vet inte vart felet låg, troligtvis i min okunskap, men jag hade önskat lite mer vägledning 
            i det kursmomentet för att få det att fungera. Nu fungerade ju SQLite bra så det var ju ingen katastrof men det var något jag tänkte på. Kursen får 10 av 10 poäng från mig, den har blivit 
            mycket bättre än tidigare version, stort tack!</p>
        </div>
    </article>
{% endblock %}